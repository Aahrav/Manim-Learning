{
    "CapsuleScene": "class CapsuleScene(Scene):\n    def construct(self):\n        circle1 = Circle(radius=3, color=BLUE).shift(LEFT * 2)\n        circle2 = Circle(radius=3, color=RED).shift(RIGHT * 2)\n        c1 = circle1.get_center()\n        c2 = circle2.get_center()\n        r1 = circle1.radius\n        r2 = circle2.radius\n        v = c2 - c1\n        dist = np.linalg.norm(v)\n        if dist == 0:\n            self.play(Create(circle1), Create(circle2))\n            self.wait()\n            return\n        a = (r1 ** 2 - r2 ** 2 + dist ** 2) / (2 * dist)\n        h_sq = r1 ** 2 - a ** 2\n        if h_sq < 0 and h_sq > -1e-8:\n            h_sq = 0.0\n        if h_sq < 0:\n            self.play(Create(circle1), Create(circle2))\n            self.wait()\n            return\n        h = np.sqrt(h_sq)\n        x0 = c1[0] + a * (c2[0] - c1[0]) / dist\n        y0 = c1[1] + a * (c2[1] - c1[1]) / dist\n        rx = -(c2[1] - c1[1]) * (h / dist)\n        ry = (c2[0] - c1[0]) * (h / dist)\n        p1 = np.array([x0 + rx, y0 + ry, 0.0])\n        p2 = np.array([x0 - rx, y0 - ry, 0.0])\n        outward_A = -(c2 - c1)\n        outward_B = (c2 - c1)\n        def safe_normalize(u):\n            n = np.linalg.norm(u)\n            return u / n if n != 0 else u\n        outward_A = safe_normalize(outward_A)\n        outward_B = safe_normalize(outward_B)\n        def get_arc_path(center, radius, p_start, p_end, outward_vec):\n            v_start = p_start - center\n            v_end = p_end - center\n            ang_start = np.arctan2(v_start[1], v_start[0])\n            ang_end = np.arctan2(v_end[1], v_end[0])\n            def norm_pos(a):\n                a = a % TAU\n                if a < 0:\n                    a += TAU\n                return a\n            ang_start = norm_pos(ang_start)\n            ang_end = norm_pos(ang_end)\n            sweep = ang_end - ang_start\n            if sweep < 0:\n                sweep += TAU\n            mid_angle_ccw = ang_start + sweep / 2.0\n            mid_angle_ccw = norm_pos(mid_angle_ccw)\n            mid_pt_ccw = center + radius * np.array([np.cos(mid_angle_ccw), np.sin(mid_angle_ccw), 0.0])\n            if np.dot(mid_pt_ccw - center, outward_vec) > 0:\n                final_sweep = sweep\n            else:\n                final_sweep = sweep - TAU\n            arc = Arc(\n                radius=radius,\n                arc_center=center,\n                start_angle=ang_start,\n                angle=final_sweep,\n                num_components=60,\n            )\n            return arc\n        arc_A_obj = get_arc_path(c1, r1, p1, p2, outward_A)\n        arc_B_obj = get_arc_path(c2, r2, p2, p1, outward_B)\n        capsule = VMobject()\n        pts_A = np.array(arc_A_obj.points)\n        pts_B = np.array(arc_B_obj.points)\n        if pts_A.shape[0] > 0:\n            pts_A[0] = p1\n            pts_A[-1] = p2\n        if pts_B.shape[0] > 0:\n            pts_B[0] = p2\n            pts_B[-1] = p1\n        capsule.append_points(pts_A)\n        capsule.append_points(pts_B)\n        capsule.close_path()\n        capsule.set_stroke(color=YELLOW, width=6)\n        capsule.set_fill(color=WHITE, opacity=0.5)\n        dot1 = Dot(point=p1, color=WHITE)\n        dot2 = Dot(point=p2, color=WHITE)\n        lbl1 = Text(\"P1\", font_size=20).next_to(dot1, UP)\n        lbl2 = Text(\"P2\", font_size=20).next_to(dot2, DOWN)\n        arrow_A = Arrow(start=c1, end=c1 + outward_A, buff=0, stroke_width=3)\n        arrow_B = Arrow(start=c2, end=c2 + outward_B, buff=0, stroke_width=3)\n        self.play(Create(circle1), Create(circle2))\n        self.wait(0.5)\n        self.play(FadeIn(dot1, lbl1), FadeIn(dot2, lbl2))\n        self.play(Create(arrow_A), Create(arrow_B))\n        self.wait(0.3)\n        self.play(DrawBorderThenFill(capsule), run_time=3)\n        self.wait(2)"
}